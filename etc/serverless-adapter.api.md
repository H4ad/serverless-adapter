## API Report File for "@h4ad/serverless-adapter"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import type { ALBEvent } from 'aws-lambda';
import type { ALBResult } from 'aws-lambda';
import type { APIGatewayProxyEvent } from 'aws-lambda/trigger/api-gateway-proxy';
import type { APIGatewayProxyEventV2 } from 'aws-lambda';
import type { APIGatewayProxyResult } from 'aws-lambda';
import type { APIGatewayProxyStructuredResultV2 } from 'aws-lambda/trigger/api-gateway-proxy';
import type Application from 'koa';
import type { CloudFrontEvent } from 'aws-lambda/common/cloudfront';
import type { CloudFrontHeaders } from 'aws-lambda/common/cloudfront';
import type { CloudFrontRequest } from 'aws-lambda';
import type { CloudFrontRequestEvent } from 'aws-lambda/trigger/cloudfront-request';
import type { CloudFrontRequestResult } from 'aws-lambda/trigger/cloudfront-request';
import type { Context } from 'aws-lambda';
import type { DynamoDBStreamEvent } from 'aws-lambda';
import type { EventBridgeEvent } from 'aws-lambda';
import type { Express as Express_2 } from 'express';
import type { FastifyInstance } from 'fastify';
import { IncomingMessage } from 'http';
import { OutgoingHttpHeaders } from 'http';
import { Readable } from 'stream';
import type { Server } from 'hapi';
import { ServerResponse } from 'http';
import type { SNSEvent } from 'aws-lambda';
import type { SQSEvent } from 'aws-lambda';
import { Writable } from 'stream';

// @public
export interface AdapterContract<TEvent, TContext, TResponse> {
    canHandle(event: unknown, context: TContext, log: ILogger): boolean;
    getAdapterName(): string;
    getRequest(event: TEvent, context: TContext, log: ILogger): AdapterRequest;
    getResponse(props: GetResponseAdapterProps<TEvent>): TResponse;
    onErrorWhileForwarding(props: OnErrorProps<TEvent, TResponse>): void;
}

// @public
export interface AdapterRequest {
    body?: Buffer;
    headers: SingleValueHeaders;
    host?: string;
    hostname?: string;
    method: string;
    path: string;
    remoteAddress?: string;
}

// @public
export class AlbAdapter implements AdapterContract<ALBEvent, Context, ALBResult> {
    constructor(options?: AlbAdapterOptions | undefined);
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    canHandle(event: unknown): event is ALBEvent;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getAdapterName(): string;
    protected getPathFromEvent(event: ALBEvent): string;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getRequest(event: ALBEvent): AdapterRequest;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getResponse({ event, headers: responseHeaders, body, isBase64Encoded, statusCode, }: GetResponseAdapterProps<ALBEvent>): ALBResult;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    onErrorWhileForwarding({ error, delegatedResolver, respondWithErrors, event, log, }: OnErrorProps<ALBEvent, ALBResult>): void;
    // (undocumented)
    protected readonly options?: AlbAdapterOptions | undefined;
}

// @public
export interface AlbAdapterOptions {
    stripBasePath?: string;
}

// @public
export class ApiGatewayV1Adapter implements AdapterContract<APIGatewayProxyEvent, Context, APIGatewayProxyResult> {
    constructor(options?: ApiGatewayV1Options | undefined);
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    canHandle(event: unknown): event is APIGatewayProxyEvent;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getAdapterName(): string;
    protected getPathFromEvent(event: APIGatewayProxyEvent): string;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getRequest(event: APIGatewayProxyEvent): AdapterRequest;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getResponse({ headers: responseHeaders, body, isBase64Encoded, statusCode, response, }: GetResponseAdapterProps<APIGatewayProxyEvent>): APIGatewayProxyResult;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    onErrorWhileForwarding({ error, delegatedResolver, respondWithErrors, event, log, }: OnErrorProps<APIGatewayProxyEvent, APIGatewayProxyResult>): void;
    // (undocumented)
    protected readonly options?: ApiGatewayV1Options | undefined;
}

// @public
export interface ApiGatewayV1Options {
    stripBasePath?: string;
}

// @public
export class ApiGatewayV2Adapter implements AdapterContract<APIGatewayProxyEventV2, Context, APIGatewayProxyStructuredResultV2> {
    constructor(options?: ApiGatewayV2Options | undefined);
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    canHandle(event: unknown): event is APIGatewayProxyEventV2;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getAdapterName(): string;
    protected getPathFromEvent(event: APIGatewayProxyEventV2): string;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getRequest(event: APIGatewayProxyEventV2): AdapterRequest;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getResponse({ headers: responseHeaders, body, isBase64Encoded, statusCode, response, }: GetResponseAdapterProps<APIGatewayProxyEventV2>): APIGatewayProxyStructuredResultV2;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    onErrorWhileForwarding({ error, delegatedResolver, respondWithErrors, event, log, }: OnErrorProps<APIGatewayProxyEventV2, APIGatewayProxyStructuredResultV2>): void;
    // (undocumented)
    protected readonly options?: ApiGatewayV2Options | undefined;
}

// @public
export interface ApiGatewayV2Options {
    stripBasePath?: string;
}

// @public @deprecated
export class AwsContextResolver<TEvent, TCallback, TResponse> implements ResolverContract<TEvent, Context, TCallback, TResponse, void> {
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    createResolver({ context, event, log, respondWithErrors, adapter, }: ResolverProps<any, Context, any, any>): Resolver<any, void>;
}

// @public
export abstract class BaseHandler<TApp, TEvent, TContext, TCallback, TResponse, TReturn> implements HandlerContract<TApp, TEvent, TContext, TCallback, TResponse, TReturn> {
    protected getAdapterByEventAndContext(event: TEvent, context: TContext, adapters: AdapterContract<TEvent, TContext, TResponse>[], log: ILogger): AdapterContract<TEvent, TContext, TResponse>;
    abstract getHandler(app: TApp, framework: FrameworkContract<TApp>, adapters: AdapterContract<TEvent, TContext, TResponse>[], resolverFactory: ResolverContract<TEvent, TContext, TCallback, TResponse, TReturn>, binarySettings: BinarySettings, respondWithErrors: boolean, log: ILogger): ServerlessHandler<TReturn>;
    protected getServerlessRequestResponseFromAdapterRequest(requestValues: AdapterRequest): [request: ServerlessRequest, response: ServerlessResponse];
}

// @public
export type BinarySettings = {
    isBinary: ((headers: Record<string, string | string[] | undefined>) => boolean) | false;
} | {
    contentTypes: (string | RegExp)[];
    contentEncodings: string[];
};

// @public
export type BothValueHeaders = Record<string, string | string[] | undefined>;

// @public
export class CallbackResolver<TEvent, TContext, TResponse> implements ResolverContract<TEvent, TContext, ServerlessCallback<any>, TResponse, void> {
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    createResolver({ callback, event, log, respondWithErrors, adapter, }: ResolverProps<TEvent, TContext, ServerlessCallback<any>, TResponse>): Resolver<any, void>;
}

// @public
export function createDefaultLogger({ level }?: LoggerOptions): ILogger;

// @public
export type CurrentInvoke<TEvent, TContext> = {
    event: TEvent | null;
    context: TContext | null;
};

// @public
export const DEFAULT_BINARY_CONTENT_TYPES: (string | RegExp)[];

// @public
export const DEFAULT_BINARY_ENCODINGS: string[];

// @public
export const DEFAULT_LAMBDA_EDGE_DISALLOWED_HEADERS: (string | RegExp)[];

// @public
export const DEFAULT_ORIGIN_MAX_RESPONSE_SIZE_IN_BYTES: number;

// @public
export const DEFAULT_VIEWER_MAX_RESPONSE_SIZE_IN_BYTES: number;

// @public
export type DefaultForwardPath = CloudFrontRequestEvent['Records'][number]['cf']['request']['uri'];

// @public
export class DefaultHandler<TApp, TEvent, TContext, TCallback, TResponse, TReturn> extends BaseHandler<TApp, TEvent, TContext, TCallback, TResponse, TReturn> {
    protected forwardRequestToFramework(app: TApp, framework: FrameworkContract<TApp>, event: TEvent, context: TContext, adapter: AdapterContract<TEvent, TContext, TResponse>, binarySettings: BinarySettings, log: ILogger): Promise<TResponse>;
    protected forwardResponse(event: TEvent, response: ServerlessResponse, adapter: AdapterContract<TEvent, TContext, TResponse>, binarySettings: BinarySettings, log: ILogger): TResponse;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getHandler(app: TApp, framework: FrameworkContract<TApp>, adapters: AdapterContract<TEvent, TContext, TResponse>[], resolverFactory: ResolverContract<TEvent, TContext, TCallback, TResponse, TReturn>, binarySettings: BinarySettings, respondWithErrors: boolean, log: ILogger): ServerlessHandler<TReturn>;
    protected onForwardResponse(log: ILogger, statusCode: number, body: string, headers: SingleValueHeaders, isBase64Encoded: boolean): void;
    protected onForwardResponseAdapterResponse(log: ILogger, successResponse: TResponse, body: string): void;
    protected onReceiveRequest(log: ILogger, event: TEvent, context: TContext, binarySettings: BinarySettings, respondWithErrors: boolean): void;
    protected onResolveAdapter(log: ILogger, adapter: AdapterContract<TEvent, TContext, TResponse>): void;
    protected onResolveForwardedResponseToFramework(log: ILogger, response: ServerlessResponse): void;
    protected onResolveRequestValues(log: ILogger, requestValues: AdapterRequest): void;
}

// @public
export type DefaultQueryString = CloudFrontRequestEvent['Records'][number]['cf']['request']['querystring'];

// @public
export type DelegatedResolver<TResponse> = {
    succeed: (response: TResponse) => void;
    fail: (error: Error) => void;
};

// @public
export class DynamoDBAdapter implements AdapterContract<DynamoDBStreamEvent, Context, IEmptyResponse> {
    constructor(options?: DynamoDBAdapterOptions | undefined);
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    canHandle(event: unknown): event is DynamoDBStreamEvent;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getAdapterName(): string;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getRequest(event: DynamoDBStreamEvent): AdapterRequest;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getResponse(): IEmptyResponse;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    onErrorWhileForwarding({ error, delegatedResolver, }: OnErrorProps<DynamoDBStreamEvent, IEmptyResponse>): void;
    // (undocumented)
    protected readonly options?: DynamoDBAdapterOptions | undefined;
}

// @public
export interface DynamoDBAdapterOptions {
    dynamoDBForwardMethod?: string;
    dynamoDBForwardPath?: string;
}

// @public
export const EmptyResponse: IEmptyResponse;

// @public
export class EventBridgeAdapter implements AdapterContract<EventBridgeEventAll, Context, IEmptyResponse> {
    constructor(options?: EventBridgeOptions | undefined);
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    canHandle(event: unknown): event is EventBridgeEventAll;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getAdapterName(): string;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getRequest(event: EventBridgeEventAll): AdapterRequest;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getResponse(): IEmptyResponse;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    onErrorWhileForwarding({ error, delegatedResolver, }: OnErrorProps<EventBridgeEventAll, IEmptyResponse>): void;
    // (undocumented)
    protected readonly options?: EventBridgeOptions | undefined;
}

// @public
export type EventBridgeEventAll = EventBridgeEvent<any, any>;

// @public
export interface EventBridgeOptions {
    eventBridgeForwardMethod?: string;
    eventBridgeForwardPath?: string;
}

// @public
export class ExpressFramework implements FrameworkContract<Express_2> {
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    sendRequest(app: Express_2, request: IncomingMessage, response: ServerResponse): void;
}

// @public
export class FastifyFramework implements FrameworkContract<FastifyInstance> {
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    sendRequest(app: FastifyInstance, request: IncomingMessage, response: ServerResponse): void;
}

// @public
export interface FrameworkContract<TApp> {
    sendRequest(app: TApp, request: IncomingMessage, response: ServerResponse): void;
}

// @public
export function getContentType(headers: BothValueHeaders): string;

// @public
export function getCurrentInvoke<TEvent = any, TContext = any>(): CurrentInvoke<TEvent, TContext>;

// @public
export function getDefaultIfUndefined<T>(value: T | undefined, defaultValue: T): T;

// @public
export function getEventBodyAsBuffer(body: string, isBase64Encoded: boolean): [body: Buffer, contentLength: number];

// @public
export function getFlattenedHeadersMap(headersMap: BothValueHeaders, separator?: string, lowerCaseKey?: boolean): Record<string, string>;

// @public
export function getMultiValueHeadersMap(headersMap: BothValueHeaders): Record<string, string[]>;

// @public
export function getPathWithQueryStringParams(path: string, queryParams: string | Record<string, string | string[] | undefined> | undefined | null): string;

// @public
export function getQueryParamsStringFromRecord(queryParamsRecord: Record<string, string | string[] | undefined> | undefined | null): string;

// @public
export interface GetResponseAdapterProps<TEvent> {
    body: string;
    event: TEvent;
    headers: BothValueHeaders;
    isBase64Encoded: boolean;
    log: ILogger;
    response?: ServerlessResponse;
    statusCode: number;
}

// @public
export interface HandlerContract<TApp, TEvent, TContext, TCallback, TResponse, TReturn> {
    getHandler(app: TApp, framework: FrameworkContract<TApp>, adapters: AdapterContract<TEvent, TContext, TResponse>[], resolverFactory: ResolverContract<TEvent, TContext, TCallback, TResponse, TReturn>, binarySettings: BinarySettings, respondWithErrors: boolean, log: ILogger): ServerlessHandler<TReturn>;
}

// @public
export class HapiFramework implements FrameworkContract<Server> {
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    sendRequest(app: Server, request: IncomingMessage, response: ServerResponse): void;
}

// @public
export type IEmptyResponse = {};

// @public
export type ILogger = Record<Exclude<LogLevels, 'none'>, LoggerFN>;

// @public
export function isBinary(headers: BothValueHeaders, binarySettings: BinarySettings): boolean;

// @public
export function isContentEncodingBinary(headers: BothValueHeaders, binaryEncodingTypes: string[]): boolean;

// @public
export function isContentTypeBinary(headers: BothValueHeaders, binaryContentTypes: (string | RegExp)[]): boolean;

// @public
export class KoaFramework implements FrameworkContract<Application> {
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    sendRequest(app: Application, request: IncomingMessage, response: ServerResponse): void;
}

// @public
export class LambdaEdgeAdapter implements AdapterContract<CloudFrontRequestEvent, Context, CloudFrontRequestResult> {
    constructor(options?: LambdaEdgeAdapterOptions | undefined);
    protected readonly cachedDisallowedHeaders: RegExp[];
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    canHandle(event: unknown): event is CloudFrontRequestEvent;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getAdapterName(): string;
    protected getFlattenedHeadersFromCloudfrontRequest(cloudFrontRequest: CloudFrontRequest): SingleValueHeaders;
    protected getHeadersForCloudfrontResponse(originalHeaders: BothValueHeaders): CloudFrontHeaders;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getRequest(event: CloudFrontRequestEvent): AdapterRequest;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getResponse(props: GetResponseAdapterProps<CloudFrontRequestEvent>): CloudFrontRequestResult;
    protected getResponseToLambdaEdge({ body, headers: frameworkHeaders, }: GetResponseAdapterProps<CloudFrontRequestEvent>): CloudFrontRequestResult;
    protected isEventTypeOrigin(content: CloudFrontEvent['config']): boolean;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    onErrorWhileForwarding({ error, delegatedResolver, }: OnErrorProps<CloudFrontRequestEvent, CloudFrontRequestResult>): void;
    // (undocumented)
    protected readonly options?: LambdaEdgeAdapterOptions | undefined;
    protected shouldStripHeader(headerKey: string): boolean;
}

// @public
export interface LambdaEdgeAdapterOptions {
    disallowedHeaders?: (string | RegExp)[];
    getPathFromEvent?: (event: CloudFrontRequestEvent['Records'][number]) => string;
    onResponseSizeExceedLimit?: (response: CloudFrontRequestResult) => CloudFrontRequestResult;
    originMaxResponseSizeInBytes?: number;
    shouldStripHeader?: (header: string) => boolean;
    shouldUseHeadersFromFramework?: boolean;
    viewerMaxResponseSizeInBytes?: number;
}

// @public
export type LoggerFN = (message: any, ...additional: any[]) => void;

// @public
export type LoggerOptions = {
    level: LogLevels;
};

// @public
export type LogLevels = 'debug' | 'verbose' | 'info' | 'warn' | 'error' | 'none';

// @public
export type MultiValueHeaders = Record<string, string[] | undefined>;

// @public
export type NewLambdaEdgeBody = CloudFrontRequestEvent['Records'][number]['cf']['request']['body'];

// @public
export const NO_OP: (...args: any[]) => any;

// Warning: (ae-forgotten-export) The symbol "Concrete" needs to be exported by the entry point index.doc.d.ts
//
// @public
export type OldLambdaEdgeBody = Concrete<CloudFrontRequestEvent['Records'][number]['cf']['request']>['body']['data'];

// @public
export interface OnErrorProps<TEvent, TResponse> {
    delegatedResolver: DelegatedResolver<TResponse>;
    error: Error;
    event: TEvent;
    log: ILogger;
    respondWithErrors: boolean;
}

// @public
export class PromiseResolver<TEvent, TContext, TCallback, TResponse, TReturn> implements ResolverContract<TEvent, TContext, TCallback, TResponse, Promise<any>> {
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    createResolver({ event, log, respondWithErrors, adapter, }: ResolverProps<TEvent, TContext, TCallback, TResponse>): Resolver<TResponse, Promise<TReturn>>;
}

// @public
export type Resolver<TResponse, TReturn> = {
    run(task: () => Promise<TResponse>): TReturn;
};

// @public
export interface ResolverContract<TEvent, TContext, TCallback, TResponse, TReturn> {
    createResolver(props: ResolverProps<TEvent, TContext, TCallback, TResponse>): Resolver<TResponse, TReturn>;
}

// @public
export type ResolverProps<TEvent, TContext, TCallback, TResponse> = {
    event: TEvent;
    respondWithErrors: boolean;
    log: ILogger;
    adapter: AdapterContract<TEvent, TContext, TResponse>;
    context?: TContext;
    callback?: TCallback;
};

// @public
export class ServerlessAdapter<TApp, TEvent, TContext, TCallback, TResponse, TReturn> {
    protected adapters: AdapterContract<TEvent, TContext, TResponse>[];
    addAdapter(adapter: AdapterContract<TEvent, TContext, TResponse>): Pick<this, 'addAdapter' | 'build'>;
    protected app: TApp;
    protected binarySettings: BinarySettings;
    build(): ServerlessHandler<TReturn>;
    protected framework?: FrameworkContract<TApp>;
    protected handler?: HandlerContract<TApp, TEvent, TContext, TCallback, TResponse, TReturn>;
    protected log: ILogger;
    static new<TApp, TEvent, TContext = any, TCallback = any, TResponse = any, TReturn = any>(app: TApp): ServerlessAdapter<TApp, TEvent, TContext, TCallback, TResponse, TReturn>;
    protected resolver?: ResolverContract<TEvent, TContext, TCallback, TResponse, TReturn>;
    protected respondWithErrors: boolean;
    setBinarySettings(binarySettings: BinarySettings): Omit<this, 'setBinarySettings'>;
    setFramework(framework: FrameworkContract<TApp>): Omit<this, 'setFramework'>;
    setHandler(handler: HandlerContract<TApp, TEvent, TContext, TCallback, TResponse, TReturn>): Omit<this, 'setHandler'>;
    setLogger(logger: ILogger): Omit<this, 'setLogger'>;
    setResolver(resolver: ResolverContract<TEvent, TContext, TCallback, TResponse, TReturn>): Omit<this, 'setResolver'>;
    setRespondWithErrors(respondWithErrors: boolean): Omit<this, 'setRespondWithErrors'>;
}

// @public
export type ServerlessCallback<TResponse> = (error: Error | null, success: TResponse | null) => void;

// @public
export type ServerlessHandler<TReturn> = (...args: any[]) => TReturn;

// @public
export class ServerlessRequest extends IncomingMessage {
    constructor({ method, url, headers, body, remoteAddress, }: ServerlessRequestProps);
    // (undocumented)
    body?: Buffer;
    // (undocumented)
    ip?: string;
}

// @public
export interface ServerlessRequestProps {
    body?: Buffer;
    headers: SingleValueHeaders;
    method: string;
    remoteAddress?: string;
    url: string;
}

// @public
export class ServerlessResponse extends ServerResponse {
    // (undocumented)
    [BODY]: any[];
    // (undocumented)
    [HEADERS]: Record<any, any>;
    constructor({ method }: ServerlessResponseProps);
    // (undocumented)
    static body(res: ServerlessResponse): Buffer;
    protected callNativeWriteHead(statusCode: number, statusMessage?: string | any | any[], obj?: any | any[]): this;
    // (undocumented)
    static from(res: IncomingMessage): ServerlessResponse;
    // (undocumented)
    _header: string;
    // (undocumented)
    get headers(): Record<any, any>;
    // (undocumented)
    static headers(res: ServerlessResponse): OutgoingHttpHeaders & Record<any, any>;
    // (undocumented)
    _headers?: Record<any, any>;
    // (undocumented)
    setHeader(key: string, value: number | string | readonly string[]): any;
    // (undocumented)
    writeHead(statusCode: number, statusMessage?: string | any | any[], obj?: any | any[]): any;
    // (undocumented)
    _wroteHeader?: boolean;
}

// @public (undocumented)
export interface ServerlessResponseProps {
    method?: string;
}

// @public
export function setCurrentInvoke<TEvent = any, TContext = any>({ event, context, }: CurrentInvoke<TEvent, TContext>): void;

// @public
export type SingleValueHeaders = Record<string, string | undefined>;

// @public
export class SNSAdapter implements AdapterContract<SNSEvent, Context, IEmptyResponse> {
    constructor(options?: SNSAdapterOptions | undefined);
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    canHandle(event: unknown): event is SNSEvent;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getAdapterName(): string;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getRequest(event: SNSEvent): AdapterRequest;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getResponse(): IEmptyResponse;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    onErrorWhileForwarding({ error, delegatedResolver, }: OnErrorProps<SNSEvent, IEmptyResponse>): void;
    // (undocumented)
    protected readonly options?: SNSAdapterOptions | undefined;
}

// @public
export interface SNSAdapterOptions {
    snsForwardMethod?: string;
    snsForwardPath?: string;
}

// @public
export class SQSAdapter implements AdapterContract<SQSEvent, Context, IEmptyResponse> {
    constructor(options?: SQSAdapterOptions | undefined);
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    canHandle(event: unknown): event is SQSEvent;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getAdapterName(): string;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getRequest(event: SQSEvent): AdapterRequest;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    getResponse(): IEmptyResponse;
    // Warning: (ae-unresolved-inheritdoc-base) The @inheritDoc tag needs a TSDoc declaration reference; signature matching is not supported yet
    //
    // (undocumented)
    onErrorWhileForwarding({ error, delegatedResolver, }: OnErrorProps<SQSEvent, IEmptyResponse>): void;
    // (undocumented)
    protected readonly options?: SQSAdapterOptions | undefined;
}

// @public
export interface SQSAdapterOptions {
    sqsForwardMethod?: string;
    sqsForwardPath?: string;
}

// @public
export function waitForStreamComplete<TStream extends Readable | Writable>(stream: TStream): Promise<TStream>;

// (No @packageDocumentation comment for this package)

```
