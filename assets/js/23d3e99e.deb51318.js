"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9559],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>h});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=l(r),h=a,m=d["".concat(c,".").concat(h)]||d[h]||u[h]||o;return r?n.createElement(m,s(s({ref:t},p),{},{components:r})):n.createElement(m,s({ref:t},p))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,s=new Array(o);s[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=r[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},8072:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var n=r(7462),a=(r(7294),r(3905));const o={sidebar_position:2},s="Architecture",i={unversionedId:"main/architecture",id:"main/architecture",title:"Architecture",description:"The main purpose of this library is to allow the developer to add support for any cloud and as many event sources as he",source:"@site/docs/main/architecture.mdx",sourceDirName:"main",slug:"/main/architecture",permalink:"/docs/main/architecture",draft:!1,editUrl:"https://github.com/H4ad/serverless-adapter/tree/main/www/docs/main/architecture.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"main",previous:{title:"Introduction",permalink:"/docs/main/intro"},next:{title:"Getting Started",permalink:"/docs/category/getting-started"}},c={},l=[{value:"Framework",id:"framework",level:2},{value:"Handler",id:"handler",level:2},{value:"Resolver",id:"resolver",level:2},{value:"Adapter",id:"adapter",level:2}],p={toc:l};function u(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"architecture"},"Architecture"),(0,a.kt)("p",null,"The main purpose of this library is to allow the developer to add support for any cloud and as many event sources as he\nwants, without having to create an issue to request the feature or copy the library code because the library doesn't\nexpose good APIs for you to extend its functionality"),(0,a.kt)("p",null,"So I refactored ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/vendia/serverless-express"},"@vendia/serverless-express")," with 4 layers of abstraction:\nFramework, Handler, Resolver and Adapter."),(0,a.kt)("h2",{id:"framework"},"Framework"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/H4ad/serverless-adapter/tree/main/src/contracts/framework.contract.ts"},"FrameworkContract")," is responsible for forwarding\nto ",(0,a.kt)("a",{parentName:"p",href:"https://nodejs.org/api/http.html#class-httpincomingmessage"},"IncomingMessage"),"\nand ",(0,a.kt)("a",{parentName:"p",href:"https://nodejs.org/api/http.html#class-httpserverresponse"},"ServerResponse")," for your application instance."),(0,a.kt)("p",null,"With this abstraction you can implement any framework you want, they just need to accept both parameters and\ncall ",(0,a.kt)("a",{parentName:"p",href:"https://nodejs.org/api/http.html#class-httpserverresponse"},"end"),"\nin ",(0,a.kt)("a",{parentName:"p",href:"https://nodejs.org/api/http.html#class-httpserverresponse"},"ServerResponse"),", so the library knows when to continue\nand return the response."),(0,a.kt)("h2",{id:"handler"},"Handler"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/H4ad/serverless-adapter/tree/main/src/contracts/handler.contract.ts"},"HandlerContract")," is responsible to get the input from the serverless and then\nmanage to call each layer of abstraction to return a response."),(0,a.kt)("p",null,"With this abstraction, you can implement different ways\nto receive input from your serverless environment."),(0,a.kt)("p",null,"They usually have the same structure, but if you need to deal with a\nvery different cloud, you can use this abstraction to add support for that cloud."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Handler is a good choice for implementing (",(0,a.kt)("del",{parentName:"p"},"monsters"),") ways to receive input.\nFor example, we can create an http server as its handler to test our serverless code without having to launch the framework. Because? I don't know, but you can.")),(0,a.kt)("h2",{id:"resolver"},"Resolver"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/H4ad/serverless-adapter/tree/main/src/contracts/resolver.contract.ts"},"ResolverContract")," is responsible for waiting for the framework to handle the\nrequest and then returning the response to the cloud. Using AWS for example, you have three ways to wait for the\nresponse: returning a promise, calling the callback, and ",(0,a.kt)("del",{parentName:"p"},"using in-context methods"),", each option has its own benefits,\nbut generally the promise option will be the better because any good cloud provider will support promises."),(0,a.kt)("h2",{id:"adapter"},"Adapter"),(0,a.kt)("p",null,"Finally, the masterpiece of this library, the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/H4ad/serverless-adapter/tree/main/src/contracts/adapter.contract.ts"},"AdapterContract")," is responsible for\nhandling the received event, transforming the request in a way that your application can understand and then\ntransforming the response in a way your cloud can understand."),(0,a.kt)("p",null,"Well, with these four contracts, you'll be able to add support to any cloud that exists (no more excuses not to use\ncloud X with NodeJS)."))}u.isMDXComponent=!0}}]);